<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор звука с коррекцией фона</title>
    <style>
        :root {
            --signal-color: #FF0000;       /* Ярко-красный */
            --background-color: #00AA00;    /* Ярко-зелёный */
            --integral-color: #0000FF;     /* Ярко-синий */
            --start-color: #FF00FF;       /* Фиолетовый для старта */
            --end-color: #FF69B4;        /* Розовый для финиша */
            --cutoff-color: #FFA500;     /* Оранжевый для момента отсечения */
            --grid-color: #E0E0E0;         /* Светло-серая сетка */
            --axis-color: #888;            /* Серые оси */
            --secondary-color: #f0f2ff;
            --accent-color: #ff6b6b;
            --text-color: #333;
            --light-text: #666;
            --border-color: #ddd;
            --history-color-1: #FF0000;    /* Красный для точки 0.25s */
            --history-color-2: #00AA00;    /* Зеленый для точки 0.50s */
            --history-color-3: #0000FF;    /* Синий для точки 0.75s */
            --history-color-4: #FF00FF;    /* Фиолетовый для точки 1.00s */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        h1 {
            color: var(--text-color);
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        canvas {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: white;
            margin: 20px auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        #status {
            color: var(--text-color);
            font-weight: 500;
            margin: 15px 0;
            min-height: 24px;
        }
        
        #status.recording {
            color: var(--accent-color);
            animation: blink 1.5s infinite;
        }
        
        #timer {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-color);
            margin: 10px 0;
        }
        
        @keyframes blink {
            50% { opacity: 0.7; }
        }
        
        #graph-title {
            font-weight: 600;
            color: var(--text-color);
            font-size: 20px;
            margin: 25px 0 10px;
            display: none;
        }
        
        button {
            background-color: #4a6bff;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(74, 107, 255, 0.3);
        }
        
        button:hover {
            background-color: #3a5bef;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(74, 107, 255, 0.4);
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .info-box {
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: left;
            border-left: 4px solid #4a6bff;
        }
        
        .legend {
            margin-top: 10px;
            font-size: 14px;
            color: #111827;
        }
        .legend span {
            margin: 0 12px;
            display: inline-flex;
            align-items: center;
        }
        .legend .color-box {
            display: inline-block;
            width: 18px;
            height: 12px;
            margin-right: 6px;
            border-radius: 3px;
        }

        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 8px;
            text-align: center;
            display: none;
        }
        
        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
        }
        
        .language-btn {
            padding: 6px 12px;
            margin: 0 2px;
            background: #f0f2ff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .language-btn.active {
            background: #4a6bff;
            color: white;
            border-color: #4a6bff;
        }
        
        .rtl {
            direction: rtl;
        }
        
        .history-section {
            margin-top: 30px;
            display: none;
        }
        
        .history-legend {
            margin-top: 15px;
            font-size: 14px;
            color: #111827;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        .history-legend span {
            display: inline-flex;
            align-items: center;
            margin: 5px 0;
        }
        .history-legend .color-box {
            display: inline-block;
            width: 18px;
            height: 12px;
            margin-right: 8px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            canvas {
                width: 100%;
                height: auto;
            }
            
            .language-selector {
                position: static;
                margin-bottom: 15px;
            }
            
            .history-legend {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="language-selector">
            <button class="language-btn active" data-lang="ru">RU</button>
            <button class="language-btn" data-lang="en">EN</button>
            <button class="language-btn" data-lang="he">HE</button>
        </div>
        
        <h1 id="main-title">Анализ интенсивности звука с коррекцией фона</h1>
        
        <div class="info-box">
            <strong id="how-to-use">Как использовать:</strong> 
            <span id="usage-description">Нажмите кнопку "Начать запись", разрешите доступ к микрофону. 
            После 15 секунд записи вы увидите график, где:</span>
            <ul>
                <li><span style="color: var(--signal-color); font-weight: bold;" id="signal-desc">Красная линия</span> - <span id="signal-text">очищенный сигнал</span></li>
                <li><span style="color: var(--background-color); font-weight: bold;" id="background-desc">Зелёная линия</span> - <span id="background-text">фоновый шум</span></li>
                <li><span style="color: var(--integral-color); font-weight: bold;" id="integral-desc">Синяя линия</span> - <span id="integral-text">интегральная кривая</span></li>
                <li><span style="color: var(--start-color); font-weight: bold;" id="start-desc">Фиолетовая линия</span> - <span id="start-text">момент старта сигнала</span></li>
                <li><span style="color: var(--end-color); font-weight: bold;" id="end-desc">Розовая линия</span> - <span id="end-text">момент окончания сигнала (99% интеграла)</span></li>
                <li><span style="color: var(--cutoff-color); font-weight: bold;" id="cutoff-desc">Оранжевая линия</span> - <span id="cutoff-text">моменты отсечения (старт + 0.25, 0.50, 0.75, 1.00 сек)</span></li>
            </ul>
        </div>
        
        <button id="startBtn">Начать запись (15 сек)</button>
        <div id="timer"></div>
        <p id="status">Готов к записи</p>
        
        <div class="results" id="results">
            <h3 id="results-title">Результаты анализа:</h3>
            <p id="start-time-result">Время старта: - сек</p>
            <p id="end-time-result">Время финиша: - сек</p>
            <p id="intensity-result">Интенсивность в точке отсечения: -</p>
        </div>
        
        <p id="graph-title">График интенсивности звука</p>
        <canvas id="graph" width="800" height="400"></canvas>
        <div class="legend">
            <span><i class="color-box" style="background: var(--signal-color);"></i> <span id="legend-signal">Сигнал</span></span>
            <span><i class="color-box" style="background: var(--background-color);"></i> <span id="legend-background">Фон</span></span>
            <span><i class="color-box" style="background: var(--integral-color);"></i> <span id="legend-integral">Интеграл</span></span>
            <span><i class="color-box" style="background: var(--start-color);"></i> <span id="legend-start">Старт</span></span>
            <span><i class="color-box" style="background: var(--end-color);"></i> <span id="legend-end">Финиш</span></span>
            <span><i class="color-box" style="background: var(--cutoff-color);"></i> <span id="legend-cutoff">Отсечение</span></span>
        </div>
        
        <div class="history-section" id="history-section">
            <h3 id="history-title">История измерений (последние 14 сеансов)</h3>
            <canvas id="history-graph" width="800" height="400"></canvas>
            <div class="history-legend">
                <span><i class="color-box" style="background: var(--history-color-1);"></i> <span>0.25 сек</span></span>
                <span><i class="color-box" style="background: var(--history-color-2);"></i> <span>0.50 сек</span></span>
                <span><i class="color-box" style="background: var(--history-color-3);"></i> <span>0.75 сек</span></span>
                <span><i class="color-box" style="background: var(--history-color-4);"></i> <span>1.00 сек</span></span>
            </div>
        </div>
    </div>

    <script>
        // Проверка поддержки Web Audio API
        if (!window.AudioContext && !window.webkitAudioContext) {
            document.getElementById('status').textContent = "Ваш браузер не поддерживает Web Audio API";
            document.getElementById('startBtn').disabled = true;
        }

        const DURATION = 15;
        const SAMPLE_RATE = 44100;
        const CHUNK_SIZE = 1024;
        const SIGNAL_AMPLIFICATION = 2.0;
        const MAX_HISTORY = 14; // Максимальное количество сохраняемых измерений

        const startBtn = document.getElementById('startBtn');
        const timerElement = document.getElementById('timer');
        const statusElement = document.getElementById('status');
        const graphTitle = document.getElementById('graph-title');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const resultsElement = document.getElementById('results');
        const startTimeResult = document.getElementById('start-time-result');
        const endTimeResult = document.getElementById('end-time-result');
        const intensityResult = document.getElementById('intensity-result');
        const languageButtons = document.querySelectorAll('.language-btn');
        const historySection = document.getElementById('history-section');
        const historyCanvas = document.getElementById('history-graph');
        const historyCtx = historyCanvas.getContext('2d');
        const historyLegend = document.querySelector('.history-legend');

        let audioContext;
        let analyser;
        let microphone;
        let recordingStartTime;
        let recordingInterval;
        let audioData = [];
        let backgroundNoise = [];
        let isRecording = false;
        let currentLanguage = 'ru';
        let measurementHistory = [];

        // Загрузка истории из localStorage
        function loadHistory() {
            try {
                const savedHistory = localStorage.getItem('measurementHistory');
                if (savedHistory) {
                    measurementHistory = JSON.parse(savedHistory);
                    // Ограничиваем историю последними 14 измерениями
                    if (measurementHistory.length > MAX_HISTORY) {
                        measurementHistory = measurementHistory.slice(-MAX_HISTORY);
                    }
                }
            } catch (e) {
                console.error('Ошибка загрузки истории:', e);
                measurementHistory = [];
            }
        }

        // Сохранение истории в localStorage
        function saveHistory() {
            try {
                localStorage.setItem('measurementHistory', JSON.stringify(measurementHistory));
            } catch (e) {
                console.error('Ошибка сохранения истории:', e);
            }
        }

        // Добавление нового измерения в истории
        function addToHistory(startTime, endTime, cutoffIntensities) {
            const now = new Date();
            const measurement = {
                timestamp: now.toISOString(),
                date: now.toLocaleDateString(),
                time: now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}),
                startTime: startTime,
                endTime: endTime,
                cutoffIntensities: cutoffIntensities
            };
            
            measurementHistory.push(measurement);
            
            // Ограничиваем историю последними 14 измерениями
            if (measurementHistory.length > MAX_HISTORY) {
                measurementHistory = measurementHistory.slice(-MAX_HISTORY);
            }
            
            saveHistory();
        }

        // Тексты для перевода
        const translations = {
            ru: {
                title: "Анализ интенсивности звука с коррекцией фона",
                howToUse: "Как использовать:",
                usageDescription: "Нажмите кнопку \"Начать запись\", разрешите доступ к микрофону. После 15 секунд записи вы увидите график, где:",
                signalDesc: "Красная линия",
                signalText: "очищенный сигнал",
                backgroundDesc: "Зелёная линия",
                backgroundText: "фоновый шум",
                integralDesc: "Синяя линия",
                integralText: "интегральная кривая",
                startDesc: "Фиолетовая линия",
                startText: "момент старта сигнала",
                endDesc: "Розовая линия",
                endText: "момент окончания сигнала (99% интеграла)",
                cutoffDesc: "Оранжевая линия",
                cutoffText: "моменты отсечения (старт + 0.25, 0.50, 0.75, 1.00 сек)",
                startButton: "Начать запись (15 сек)",
                readyStatus: "Готов к записи",
                recordingStatus: "Идёт запись...",
                analyzingStatus: "Анализ данных...",
                completeStatus: "Анализ завершен",
                resultsTitle: "Результаты анализа:",
                startTimeResult: "Время старта:",
                endTimeResult: "Время финиша:",
                intensityResult: "Интенсивность в точке отсечения:",
                graphTitle: "График интенсивности звука",
                historyTitle: "История измерений (последние 14 сеансов)",
                legendSignal: "Сигнал",
                legendBackground: "Фон",
                legendIntegral: "Интеграл",
                legendStart: "Старт",
                legendEnd: "Финиш",
                legendCutoff: "Отсечение",
                timeLeft: "Осталось:",
                seconds: "сек",
                notDetected: "не обнаружено",
                notAvailable: "не доступно",
                startLabel: "Старт",
                finishLabel: "Финиш (99%)",
                cutoffLabel: "Отсечение",
                timeLabel: "Время (секунды)",
                intensityLabel: "Нормированная интенсивность",
                dateLabel: "Дата и время измерений",
                intensityHistoryLabel: "Интенсивность"
            },
            en: {
                title: "Sound Intensity Analysis with Background Correction",
                howToUse: "How to use:",
                usageDescription: "Click the \"Start Recording\" button, allow microphone access. After 15 seconds of recording, you will see a graph where:",
                signalDesc: "Red line",
                signalText: "cleaned signal",
                backgroundDesc: "Green line",
                backgroundText: "background noise",
                integralDesc: "Blue line",
                integralText: "integral curve",
                startDesc: "Purple line",
                startText: "signal start moment",
                endDesc: "Pink line",
                endText: "signal end moment (99% of integral)",
                cutoffDesc: "Orange line",
                cutoffText: "cutoff moments (start + 0.25, 0.50, 0.75, 1.00 sec)",
                startButton: "Start Recording (15 sec)",
                readyStatus: "Ready to record",
                recordingStatus: "Recording...",
                analyzingStatus: "Analyzing data...",
                completeStatus: "Analysis complete",
                resultsTitle: "Analysis Results:",
                startTimeResult: "Start time:",
                endTimeResult: "Finish time:",
                intensityResult: "Intensity at cutoff point:",
                graphTitle: "Sound Intensity Graph",
                historyTitle: "Measurement History (last 14 sessions)",
                legendSignal: "Signal",
                legendBackground: "Background",
                legendIntegral: "Integral",
                legendStart: "Start",
                legendEnd: "Finish",
                legendCutoff: "Cutoff",
                timeLeft: "Time left:",
                seconds: "sec",
                notDetected: "not detected",
                notAvailable: "not available",
                startLabel: "Start",
                finishLabel: "Finish (99%)",
                cutoffLabel: "Cutoff",
                timeLabel: "Time (seconds)",
                intensityLabel: "Normalized intensity",
                dateLabel: "Date and time of measurements",
                intensityHistoryLabel: "Intensity"
            },
            he: {
                title: "ניתוח עוצמת קול עם תיקון רקע",
                howToUse: "כיצד להשתמש:",
                usageDescription: "לחץ על הכפתור \"התחל הקלטה\", אשר גישה למיקרופון. לאחר 15 שניות של הקלטה, תראה גרף שבו:",
                signalDesc: "קו אדום",
                signalText: "אות נקי",
                backgroundDesc: "קו ירוק",
                backgroundText: "רעש רקע",
                integralDesc: "קו כחול",
                integralText: "עקומה אינטגרלית",
                startDesc: "קו סגול",
                startText: "רגע תחילת האות",
                endDesc: "קו ורוד",
                endText: "רגע סיום האות (99% מהאינטגרל)",
                cutoffDesc: "קו כתום",
                cutoffText: "רגעי החיתוך (תחילה + 0.25, 0.50, 0.75, 1.00 שניות)",
                startButton: "התחל הקלטה (15 שניות)",
                readyStatus: "מוכן להקלטה",
                recordingStatus: "מקליט...",
                analyzingStatus: "מנתח נתונים...",
                completeStatus: "הניתוח הושלם",
                resultsTitle: "תוצאות ניתוח:",
                startTimeResult: "זמן התחלה:",
                endTimeResult: "זמן סיום:",
                intensityResult: "עוצמה בנקודת החיתוך:",
                graphTitle: "גרף עוצמת קול",
                historyTitle: "היסטוריית מדידות (14 המדידות האחרונות)",
                legendSignal: "אות",
                legendBackground: "רקע",
                legendIntegral: "אינטגרל",
                legendStart: "התחלה",
                legendEnd: "סיום",
                legendCutoff: "חיתוך",
                timeLeft: "נשארו:",
                seconds: "שניות",
                notDetected: "לא אותר",
                notAvailable: "לא זמין",
                startLabel: "התחלה",
                finishLabel: "סיום (99%)",
                cutoffLabel: "חיתוך",
                timeLabel: "זמן (שניות)",
                intensityLabel: "עוצמה מנורמלת",
                dateLabel: "תאריך ושעה של המדידות",
                intensityHistoryLabel: "עוצמה"
            }
        };

        // Функция смены языка
        function changeLanguage(lang) {
            currentLanguage = lang;
            const t = translations[lang];
            
            // Обновляем тексты интерфейса
            document.getElementById('main-title').textContent = t.title;
            document.getElementById('how-to-use').textContent = t.howToUse;
            document.getElementById('usage-description').textContent = t.usageDescription;
            document.getElementById('signal-desc').textContent = t.signalDesc;
            document.getElementById('signal-text').textContent = t.signalText;
            document.getElementById('background-desc').textContent = t.backgroundDesc;
            document.getElementById('background-text').textContent = t.backgroundText;
            document.getElementById('integral-desc').textContent = t.integralDesc;
            document.getElementById('integral-text').textContent = t.integralText;
            document.getElementById('start-desc').textContent = t.startDesc;
            document.getElementById('start-text').textContent = t.startText;
            document.getElementById('end-desc').textContent = t.endDesc;
            document.getElementById('end-text').textContent = t.endText;
            document.getElementById('cutoff-desc').textContent = t.cutoffDesc;
            document.getElementById('cutoff-text').textContent = t.cutoffText;
            startBtn.textContent = t.startButton;
            document.getElementById('results-title').textContent = t.resultsTitle;
            document.getElementById('graph-title').textContent = t.graphTitle;
            document.getElementById('history-title').textContent = t.historyTitle;
            document.getElementById('legend-signal').textContent = t.legendSignal;
            document.getElementById('legend-background').textContent = t.legendBackground;
            document.getElementById('legend-integral').textContent = t.legendIntegral;
            document.getElementById('legend-start').textContent = t.legendStart;
            document.getElementById('legend-end').textContent = t.legendEnd;
            document.getElementById('legend-cutoff').textContent = t.legendCutoff;
            
            // Обновляем статус, если не идет запись
            if (!isRecording) {
                statusElement.textContent = t.readyStatus;
            }
            
            // Обновляем направление текста для иврита
            if (lang === 'he') {
                document.body.classList.add('rtl');
                document.querySelector('.container').style.direction = 'rtl';
                document.querySelector('.info-box').style.textAlign = 'right';
            } else {
                document.body.classList.remove('rtl');
                document.querySelector('.container').style.direction = 'ltr';
                document.querySelector('.info-box').style.textAlign = 'left';
            }
            
            // Обновляем активную кнопку языка
            languageButtons.forEach(btn => {
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Перерисовываем график, если данные уже есть
            if (audioData.length > 0) {
                processAndDrawData();
            }
            
            // Перерисовываем график истории
            if (measurementHistory.length > 0) {
                drawHistoryGraph();
            }
        }

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SAMPLE_RATE
                });
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                return true;
            } catch (e) {
                console.error("Ошибка инициализации аудио:", e);
                statusElement.textContent = translations[currentLanguage].errorAudioInit || "Ошибка инициализации аудио";
                return false;
            }
        }

        async function startRecording() {
            try {
                if (!audioContext && !initAudio()) {
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                recordingStartTime = audioContext.currentTime;
                isRecording = true;
                audioData = [];
                backgroundNoise = [];
                
                startBtn.disabled = true;
                statusElement.textContent = translations[currentLanguage].recordingStatus;
                statusElement.classList.add('recording');
                graphTitle.style.display = 'none';
                resultsElement.style.display = 'none';
                historySection.style.display = 'none';
                
                processAudio();
                
                let secondsLeft = DURATION;
                updateTimer(secondsLeft);
                
                recordingInterval = setInterval(() => {
                    secondsLeft--;
                    updateTimer(secondsLeft);
                    
                    if (secondsLeft <= 0) {
                        stopRecording();
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Ошибка при записи:', error);
                statusElement.textContent = translations[currentLanguage].errorRecording || "Ошибка записи: " + error.message;
                resetRecordingState();
            }
        }

        function processAudio() {
            if (!isRecording) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            const timestamp = audioContext.currentTime - recordingStartTime;
            
            // Усиление сигнала вдвое
            const normalizedData = Array.from(dataArray).map(x => (x - 128) / 128 * SIGNAL_AMPLIFICATION);
            
            audioData.push({
                time: timestamp,
                data: normalizedData
            });
            
            if (timestamp < 2) {
                backgroundNoise.push({
                    x: timestamp / DURATION,
                    y: calculateRMS(normalizedData)
                });
            }
            
            requestAnimationFrame(processAudio);
        }

        function calculateRMS(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i] * data[i];
            }
            return Math.sqrt(sum / data.length);
        }

        function stopRecording() {
            clearInterval(recordingInterval);
            isRecording = false;
            
            if (microphone) {
                microphone.disconnect();
            }
            
            statusElement.textContent = translations[currentLanguage].analyzingStatus;
            statusElement.classList.remove('recoring');
            
            setTimeout(() => {
                processAndDrawData();
                resetRecordingState();
            }, 500);
        }

        function findSignalStart(integralData, sampleRate) {
            const SMOOTHING_WINDOW = 0.5;
            const THRESHOLD_FACTOR = 5;
            const MIN_DURATION = 0.3;
            const START_IGNORE_TIME = 0.5;

            const windowSize = Math.floor(SMOOTHING_WINDOW * sampleRate);
            let startIndex = -1;

            let means = [], stdDevs = [];
            for (let i = 0; i < integralData.length; i++) {
                const start = Math.max(0, i - windowSize);
                const window = integralData.slice(start, i).map(p => p.y);
                const mean = window.reduce((a, b) => a + b, 0) / window.length;
                const stdDev = window.length > 1 ? 
                    Math.sqrt(window.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (window.length - 1)) : 0;
                
                means.push(mean);
                stdDevs.push(stdDev);
            }

            const ignoreIndex = Math.floor(START_IGNORE_TIME * sampleRate);
            for (let i = ignoreIndex; i < integralData.length; i++) {
                const threshold = means[i] + THRESHOLD_FACTOR * stdDevs[i];
                
                if (integralData[i].y > threshold) {
                    let isSignal = true;
                    for (let j = i; j < Math.min(i + MIN_DURATION * sampleRate, integralData.length); j++) {
                        if (integralData[j].y <= threshold) {
                            isSignal = false;
                            break;
                        }
                    }
                    if (isSignal) {
                        startIndex = i;
                        break;
                    }
                }
            }

            return startIndex >= 0 ? integralData[startIndex].x * DURATION : -1;
        }

        function findSignalEnd(integralData, sampleRate, startTime) {
            if (startTime < 0) return -1;

            const maxIntegralValue = Math.max(...integralData.map(p => p.y));
            if (maxIntegralValue <= 0) return -1;

            const targetValue = 0.99 * maxIntegralValue;
            let endIndex = -1;

            for (let i = 0; i < integralData.length; i++) {
                if (integralData[i].y >= targetValue) {
                    endIndex = i;
                    break;
                }
            }

            return endIndex >= 0 ? integralData[endIndex].x * DURATION : -1;
        }

        function processAndDrawData() {
            if (audioData.length === 0) {
                statusElement.textContent = translations[currentLanguage].noData || "Нет данных для анализа";
                return;
            }
            
            try {
                const avgBackgroundNoise = backgroundNoise.reduce((sum, point) => sum + point.y, 0) / backgroundNoise.length;
                
                const originalSignal = [];
                const backgroundSignal = [];
                const timeStep = DURATION / audioData.length;
                
                for (let i = 0; i < audioData.length; i++) {
                    const point = audioData[i];
                    const intensity = calculateRMS(point.data);
                    
                    originalSignal.push(intensity);
                    backgroundSignal.push({
                        x: point.time / DURATION,
                        y: avgBackgroundNoise
                    });
                }
                
                const integralSignal = calculateIntegralCurve(originalSignal, avgBackgroundNoise);
                
                const sampleRate = audioData.length / DURATION;
                const startTime = findSignalStart(integralSignal, sampleRate);
                const endTime = findSignalEnd(integralSignal, sampleRate, startTime);
                
                // Вычисляем моменты отсечения
                const cutoffTimes = [];
                if (startTime > 0) {
                    cutoffTimes.push(startTime + 0.25);
                    cutoffTimes.push(startTime + 0.50);
                    cutoffTimes.push(startTime + 0.75);
                    cutoffTimes.push(startTime + 1.00);
                }
                
                console.log("Start time:", startTime, "End time:", endTime, "Cutoff times:", cutoffTimes);
                
                const maxIntegralValue = Math.max(...integralSignal.map(p => p.y));
                const normalizedIntegral = integralSignal.map(p => ({
                    x: p.x,
                    y: maxIntegralValue > 0 ? p.y / maxIntegralValue : 0
                }));
                
                // Вычисляем интенсивность в точках отсечения
                const cutoffIntensities = [];
                if (startTime > 0) {
                    for (const cutoffTime of cutoffTimes) {
                        if (cutoffTime > 0 && cutoffTime < DURATION) {
                            const cutoffIndex = Math.floor(cutoffTime / timeStep);
                            if (cutoffIndex >= 0 && cutoffIndex < normalizedIntegral.length) {
                                cutoffIntensities.push(normalizedIntegral[cutoffIndex].y);
                            } else {
                                cutoffIntensities.push(-1);
                            }
                        } else {
                            cutoffIntensities.push(-1);
                        }
                    }
                }
                
                // Добавляем в историю
                if (startTime > 0) {
                    addToHistory(startTime, endTime, cutoffIntensities);
                }
                
                // Показываем результаты анализа
                showResults(startTime, endTime, cutoffIntensities);
                
                graphTitle.style.display = 'block';
                drawGraphWithBackground(
                    originalSignal, 
                    backgroundSignal, 
                    normalizedIntegral,
                    timeStep, 
                    startTime, 
                    endTime, 
                    cutoffTimes
                );
                
                // Показываем график истории
                if (measurementHistory.length > 0) {
                    historySection.style.display = 'block';
                    drawHistoryGraph();
                }
                
                statusElement.textContent = translations[currentLanguage].completeStatus;
            } catch (error) {
                console.error('Ошибка при обработке данных:', error);
                statusElement.textContent = translations[currentLanguage].errorAnalysis || "Ошибка анализа данных";
            }
        }

        function showResults(startTime, endTime, cutoffIntensities) {
            resultsElement.style.display = 'block';
            const t = translations[currentLanguage];
            
            if (startTime > 0) {
                startTimeResult.textContent = `${t.startTimeResult} ${startTime.toFixed(2)} ${t.seconds}`;
            } else {
                startTimeResult.textContent = `${t.startTimeResult} ${t.notDetected}`;
            }
            
            if (endTime > 0) {
                endTimeResult.textContent = `${t.endTimeResult} ${endTime.toFixed(2)} ${t.seconds}`;
            } else {
                endTimeResult.textContent = `${t.endTimeResult} ${t.notDetected}`;
            }
            
            if (cutoffIntensities && cutoffIntensities.length > 0) {
                let intensityText = `${t.intensityResult} `;
                for (let i = 0; i < cutoffIntensities.length; i++) {
                    if (cutoffIntensities[i] >= 0) {
                        intensityText += `${cutoffIntensities[i].toFixed(4)}`;
                    } else {
                        intensityText += `${t.notAvailable}`;
                    }
                    if (i < cutoffIntensities.length - 1) {
                        intensityText += ", ";
                    }
                }
                intensityResult.textContent = intensityText;
            } else {
                intensityResult.textContent = `${t.intensityResult} ${t.notAvailable}`;
            }
        }

        function calculateIntegralCurve(signal, backgroundLevel) {
            const integralPoints = [];
            let integralValue = 0;
            const timeStep = DURATION / signal.length;
            
            for (let i = 0; i < signal.length; i++) {
                const signalValue = Math.max(0, signal[i] - backgroundLevel * 0.8);
                integralValue += signalValue * timeStep;
                
                integralPoints.push({
                    x: i * timeStep / DURATION,
                    y: integralValue
                });
            }
            
            return integralPoints;
        }

        function updateTimer(seconds) {
            timerElement.textContent = `${translations[currentLanguage].timeLeft} ${seconds} ${translations[currentLanguage].seconds}`;
        }

        function resetRecordingState() {
            startBtn.disabled = false;
            timerElement.textContent = '';
        }

        function drawGraphWithBackground(
            originalData, 
            backgroundData, 
            integralData,
            timeStep, 
            startTime, 
            endTime, 
            cutoffTimes
        ) {
            if (!originalData || !backgroundData || !integralData || !timeStep) {
                console.error('Некорректные параметры для drawGraphWithBackground');
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Сетка и оси
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color').trim();
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 1; i += 0.1) {
                const y = canvas.height - i * canvas.height;
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-color').trim();
            ctx.lineWidth = 2;
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.moveTo(0, 0);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();

            // Фон (зелёный)
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--background-color').trim();
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            for (let i = 0; i < backgroundData.length; i++) {
                const x = backgroundData[i].x * canvas.width;
                const y = canvas.height - backgroundData[i].y * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Очищенный сигнал (красный)
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--signal-color').trim();
            ctx.lineWidth = 3;
            for (let i = 0; i < backgroundData.length; i++) {
                const originalIndex = Math.round(backgroundData[i].x * originalData.length);
                const originalValue = originalData[Math.min(originalIndex, originalData.length - 1)];
                const backgroundValue = backgroundData[i].y;
                const cleanedValue = Math.max(0, originalValue - backgroundValue * 0.8);
                
                const x = backgroundData[i].x * canvas.width;
                const y = canvas.height - cleanedValue * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Интегральная кривая (синяя)
            ctx.beginPath();
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--integral-color').trim();
            ctx.lineWidth = 3;
            ctx.setLineDash([3, 3]);
            for (let i = 0; i < integralData.length; i++) {
                const x = integralData[i].x * canvas.width;
                const y = canvas.height - integralData[i].y * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Отметка старта сигнала
            const t = translations[currentLanguage];
            if (startTime > 0 && startTime < DURATION) {
                const startX = (startTime / DURATION) * canvas.width;
                
                ctx.beginPath();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--start-color').trim();
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.moveTo(startX, 0);
                ctx.lineTo(startX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.font = '14px "Segoe UI", sans-serif';
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--start-color').trim();
                ctx.textAlign = 'center';
                ctx.fillText(`${t.startLabel} - ${startTime.toFixed(1)} ${t.seconds}`, startX, canvas.height + 20);
            }

            // Отметка финиша сигнала (99% интеграла)
            if (endTime > 0 && endTime < DURATION) {
                const endX = (endTime / DURATION) * canvas.width;
                
                ctx.beginPath();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--end-color').trim();
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.moveTo(endX, 0);
                ctx.lineTo(endX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.font = '14px "Segoe UI", sans-serif';
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--end-color').trim();
                ctx.textAlign = 'center';
                ctx.fillText(`${t.finishLabel} - ${endTime.toFixed(1)} ${t.seconds}`, endX, canvas.height + 40);
            }

            // Отметки моментов отсечения
            if (cutoffTimes && cutoffTimes.length > 0 && startTime > 0) {
                const cutoffLabels = ["0.25s", "0.50s", "0.75s", "1.00s"];
                
                for (let i = 0; i < cutoffTimes.length; i++) {
                    const cutoffTime = cutoffTimes[i];
                    if (cutoffTime > 0 && cutoffTime < DURATION) {
                        const cutoffX = (cutoffTime / DURATION) * canvas.width;
                        
                        ctx.beginPath();
                        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--cutoff-color').trim();
                        ctx.lineWidth = 2;
                        ctx.setLineDash([3, 3]);
                        ctx.moveTo(cutoffX, 0);
                        ctx.lineTo(cutoffX, canvas.height);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        ctx.font = '12px "Segoe UI", sans-serif';
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cutoff-color').trim();
                        ctx.textAlign = 'center';
                        ctx.fillText(`${t.cutoffLabel} ${cutoffLabels[i]} - ${cutoffTime.toFixed(2)} ${t.seconds}`, 
                                    cutoffX, canvas.height + 60 + i * 20);
                    }
                }
            }

            // Подписи осей
            ctx.font = '12px "Segoe UI", sans-serif';
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            
            ctx.textAlign = 'center';
            for (let i = 0; i <= DURATION; i += 1) {
                const x = (i / DURATION) * canvas.width;
                ctx.fillText(i.toString(), x, canvas.height - 8);
            }
            ctx.fillText(t.timeLabel, canvas.width / 2, canvas.height - 15);
            
            ctx.textAlign = 'right';
            for (let i = 0; i <= 1; i += 0.2) {
                const y = canvas.height - i * canvas.height;
                ctx.fillText(i.toFixed(1), 30, y + 4);
            }
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(t.intensityLabel, 0, 0);
            ctx.restore();
        }

        function drawHistoryGraph() {
            if (measurementHistory.length === 0) return;

            historyCtx.clearRect(0, 0, historyCanvas.width, historyCanvas.height);
            
            const t = translations[currentLanguage];
            const padding = 60;
            const graphWidth = historyCanvas.width - padding * 2;
            const graphHeight = historyCanvas.height - padding * 2;
            
            // Сетка и оси
            historyCtx.beginPath();
            historyCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color').trim();
            historyCtx.lineWidth = 1;
            
            // Горизонтальные линии
            for (let i = 0; i <= 1; i += 0.2) {
                const y = padding + graphHeight - i * graphHeight;
                historyCtx.moveTo(padding, y);
                historyCtx.lineTo(padding + graphWidth, y);
            }
            
            // Вертикальные линии
            for (let i = 0; i < measurementHistory.length; i++) {
                const x = padding + (i / (measurementHistory.length - 1)) * graphWidth;
                historyCtx.moveTo(x, padding);
                historyCtx.lineTo(x, padding + graphHeight);
            }
            historyCtx.stroke();

            // Оси
            historyCtx.beginPath();
            historyCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--axis-color').trim();
            historyCtx.lineWidth = 2;
            historyCtx.moveTo(padding, padding + graphHeight);
            historyCtx.lineTo(padding + graphWidth, padding + graphHeight);
            historyCtx.moveTo(padding, padding);
            historyCtx.lineTo(padding, padding + graphHeight);
            historyCtx.stroke();

            // Цвета для линий
            const colors = [
                getComputedStyle(document.documentElement).getPropertyValue('--history-color-1').trim(),
                getComputedStyle(document.documentElement).getPropertyValue('--history-color-2').trim(),
                getComputedStyle(document.documentElement).getPropertyValue('--history-color-3').trim(),
                getComputedStyle(document.documentElement).getPropertyValue('--history-color-4').trim()
            ];

            // Рисуем 4 линии для каждого момента отсечения
            for (let pointIndex = 0; pointIndex < 4; pointIndex++) {
                historyCtx.beginPath();
                historyCtx.strokeStyle = colors[pointIndex];
                historyCtx.lineWidth = 3;
                
                for (let i = 0; i < measurementHistory.length; i++) {
                    const measurement = measurementHistory[i];
                    if (measurement.cutoffIntensities && measurement.cutoffIntensities[pointIndex] >= 0) {
                        const x = padding + (i / (measurementHistory.length - 1)) * graphWidth;
                        const y = padding + graphHeight - measurement.cutoffIntensities[pointIndex] * graphHeight;
                        
                        if (i === 0) {
                            historyCtx.moveTo(x, y);
                        } else {
                            historyCtx.lineTo(x, y);
                        }
                    }
                }
                historyCtx.stroke();
                
                // Точки на графике
                for (let i = 0; i < measurementHistory.length; i++) {
                    const measurement = measurementHistory[i];
                    if (measurement.cutoffIntensities && measurement.cutoffIntensities[pointIndex] >= 0) {
                        const x = padding + (i / (measurementHistory.length - 1)) * graphWidth;
                        const y = padding + graphHeight - measurement.cutoffIntensities[pointIndex] * graphHeight;
                        
                        historyCtx.beginPath();
                        historyCtx.fillStyle = colors[pointIndex];
                        historyCtx.arc(x, y, 5, 0, Math.PI * 2);
                        historyCtx.fill();
                    }
                }
            }

            // Подписи осей
            historyCtx.font = '12px "Segoe UI", sans-serif';
            historyCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            
            // Подписи по оси Y
            historyCtx.textAlign = 'right';
            for (let i = 0; i <= 1; i += 0.2) {
                const y = padding + graphHeight - i * graphHeight;
                historyCtx.fillText(i.toFixed(1), padding - 10, y + 4);
            }
            
            // Подписи по оси X (даты)
            historyCtx.textAlign = 'center';
            for (let i = 0; i < measurementHistory.length; i++) {
                const measurement = measurementHistory[i];
                const x = padding + (i / (measurementHistory.length - 1)) * graphWidth;
                historyCtx.save();
                historyCtx.translate(x, padding + graphHeight + 20);
                historyCtx.rotate(-Math.PI / 4);
                historyCtx.fillText(measurement.date + ' ' + measurement.time, 0, 0);
                historyCtx.restore();
            }
            
            // Названия осей
            historyCtx.textAlign = 'center';
            historyCtx.fillText(t.dateLabel, padding + graphWidth / 2, historyCanvas.height - 15);
            
            historyCtx.save();
            historyCtx.translate(15, padding + graphHeight / 2);
            historyCtx.rotate(-Math.PI / 2);
            historyCtx.textAlign = 'center';
            historyCtx.fillText(t.intensityHistoryLabel, 0, 0);
            historyCtx.restore();
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Загружаем историю при запуске
            loadHistory();
            
            // Если есть история, показываем график
            if (measurementHistory.length > 0) {
                historySection.style.display = 'block';
                drawHistoryGraph();
            }
            
            startBtn.addEventListener('click', startRecording);
            
            // Добавляем обработчики для кнопок переключения языка
            languageButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    changeLanguage(btn.dataset.lang);
                });
            });
        });
    </script>
</body>
</html>