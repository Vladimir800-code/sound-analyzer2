<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Анализатор звука с коррекцией фона</title>
    <style>
        :root {
            --signal-color: #FF0000;       /* Ярко-красный */
            --background-color: #00AA00;    /* Ярко-зелёный */
            --integral-color: #0000FF;     /* Ярко-синий */
            --start-color: #FF00FF;       /* Фиолетовый для старта */
            --end-color: #FF69B4;        /* Розовая для финиша */
            --cutoff-color: #FFA500;     /* Оранжевый для момента отсечения */
            --grid-color: #E0E0E0;         /* Светло-серая сетка */
            --axis-color: #888;            /* Серые оси */
            --secondary-color: #f0f2ff;
            --accent-color: #ff6b6b;
            --text-color: #333;
            --light-text: #666;
            --border-color: #ddd;
            --history-color-1: #FF0000;    /* Красный для точки 0.25s */
            --history-color-2: #00AA00;    /* Зеленый для точки 0.50s */
            --history-color-3: #0000FF;    /* Синий для точки 0.75s */
            --history-color-4: #FF00FF;    /* Фиолетовый для точки 1.00s */
            --delete-color: #ff4757;       /* Цвет для кнопки удаления */
            --good-zone-color: rgba(0, 255, 0, 0.15);     /* Зеленая зона (прозрачная) */
            --warning-zone-color: rgba(255, 255, 0, 0.15); /* Желтая зона (прозрачная) */
            --bad-zone-color: rgba(255, 0, 0, 0.15);      /* Красная зона (прозрачная) */
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            margin: 0;
            padding: 20px;
            background-color: #f9f9f9;
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        h1 {
            color: var(--text-color);
            margin-bottom: 20px;
            font-weight: 600;
        }
        
        canvas {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: white;
            margin: 20px auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        #status {
            color: var(--text-color);
            font-weight: 500;
            margin: 15px 0;
            min-height: 24px;
        }
        
        #status.recording {
            color: var(--accent-color);
            animation: blink 1.5s infinite;
        }
        
        #timer {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-color);
            margin: 10px 0;
        }
        
        @keyframes blink {
            50% { opacity: 0.7; }
        }
        
        #graph-title {
            font-weight: 600;
            color: var(--text-color);
            font-size: 20px;
            margin: 25px 0 10px;
            display: none;
        }
        
        button {
            background-color: #4a6bff;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 2px 10px rgba(74, 107, 255, 0.3);
        }
        
        button:hover {
            background-color: #3a5bef;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(74, 107, 255, 0.4);
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .info-box {
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: left;
            border-left: 4px solid #4a6bff;
        }
        
        .legend {
            margin-top: 10px;
            font-size: 14px;
            color: #111827;
        }
        .legend span {
            margin: 0 12px;
            display: inline-flex;
            align-items: center;
        }
        .legend .color-box {
            display: inline-block;
            width: 18px;
            height: 12px;
            margin-right: 6px;
            border-radius: 3px;
        }

        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: var(--secondary-color);
            border-radius: 8px;
            text-align: center;
            display: none;
        }
        
        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
        }
        
        .language-btn {
            padding: 6px 12px;
            margin: 0 2px;
            background: #f0f2ff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .language-btn.active {
            background: #4a6bff;
            color: white;
            border-color: #4a6bff;
        }
        
        .rtl {
            direction: rtl;
        }
        
        .history-section {
            margin-top: 30px;
            display: none;
        }
        
        .history-legend {
            margin-top: 15px;
            font-size: 14px;
            color: #111827;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        .history-legend span {
            display: inline-flex;
            align-items: center;
            margin: 5px 0;
        }
        .history-legend .color-box {
            display: inline-block;
            width: 18px;
            height: 12px;
            margin-right: 8px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }
        
        .history-zone-legend {
            margin-top: 15px;
            font-size: 14px;
            color: #111827;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        .history-zone-legend span {
            display: inline-flex;
            align-items: center;
            margin: 5px 0;
        }
        .history-zone-legend .color-box {
            display: inline-block;
            width: 18px;
            height: 12px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .delete-btn {
            background-color: var(--delete-color);
            padding: 8px 16px;
            margin-top: 10px;
            font-size: 14px;
        }
        
        .delete-btn:hover {
            background-color: #ff2e43;
        }
        
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .history-title {
            margin: 0;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            canvas {
                width: 100%;
                height: auto;
            }
            
            .language-selector {
                position: static;
                margin-bottom: 15px;
            }
            
            .history-legend, .history-zone-legend {
                flex-direction: column;
                gap: 10px;
            }
            
            .history-header {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="language-selector">
            <button class="language-btn active" data-lang="ru">RU</button>
            <button class="language-btn" data-lang="en">EN</button>
            <button class="language-btn" data-lang="he">HE</button>
        </div>
        
        <h1 id="main-title">Анализ интенсивности звука с коррекцией фона</h1>
        
        <div class="info-box">
            <strong id="how-to-use">Как использовать:</strong> 
            <span id="usage-description">Нажмите кнопку "Начать запись", разрешите доступ к микрофону. 
            После 15 секунд записи вы увидите график, где:</span>
            <ul>
                <li><span style="color: var(--signal-color); font-weight: bold;" id="signal-desc">Красная линия</span> - <span id="signal-text">очищенный сигнал</span></li>
                <li><span style="color: var(--background-color); font-weight: bold;" id="background-desc">Зелёная линия</span> - <span id="background-text">фоновый шум</span></li>
                <li><span style="color: var(--integral-color); font-weight: bold;" id="integral-desc">Синяя линия</span> - <span id="integral-text">интегральная кривая</span></li>
                <li><span style="color: var(--start-color); font-weight: bold;" id="start-desc">Фиолетовая линия</span> - <span id="start-text">момент старта сигнала</span></li>
                <li><span style="color: var(--end-color); font-weight: bold;" id="end-desc">Розовая линия</span> - <span id="end-text">момент окончания сигнала (99% интеграла)</span></li>
                <li><span style="color: var(--cutoff-color); font-weight: bold;" id="cutoff-desc">Оранжевая линия</span> - <span id="cutoff-text">моменты отсечения (старт + 0.25, 0.50, 0.75, 1.00 сек)</span></li>
            </ul>
        </div>
        
        <button id="startBtn">Начать запись (15 сек)</button>
        <div id="timer"></div>
        <p id="status">Готов к записи</p>
        
        <div class="results" id="results">
            <h3 id="results-title">Результаты анализа:</h3>
            <p id="start-time-result">Время старта: - сек</p>
            <p id="end-time-result">Время финиша: - сек</p>
            <p id="intensity-result">Интенсивность в точке отсечения: -</p>
        </div>
        
        <p id="graph-title">График интенсивности звука</p>
        <canvas id="graph" width="800" height="400"></canvas>
        <div class="legend">
            <span><i class="color-box" style="background: var(--signal-color);"></i> <span id="legend-signal">Сигнал</span></span>
            <span><i class="color-box" style="background: var(--background-color);"></i> <span id="legend-background">Фон</span></span>
            <span><i class="color-box" style="background: var(--integral-color);"></i> <span id="legend-integral">Интеграл</span></span>
            <span><i class="color-box" style="background: var(--start-color);"></i> <span id="legend-start">Старт</span></span>
            <span><i class="color-box" style="background: var(--end-color);"></i> <span id="legend-end">Финиш</span></span>
            <span><i class="color-box" style="background: var(--cutoff-color);"></i> <span id="legend-cutoff">Отсечение</span></span>
        </div>
        
        <div class="history-section" id="history-section">
            <div class="history-header">
                <h3 id="history-title">История измерений (последние 14 сеансов)</h3>
                <button id="deleteLastBtn" class="delete-btn" style="display: none;">Удалить последнюю запись</button>
            </div>
            <canvas id="history-graph" width="800" height="400"></canvas>
            <div class="history-legend">
                <span><i class="color-box" style="background: var(--history-color-1);"></i> <span>0.25 сек</span></span>
                <span><i class="color-box" style="background: var(--history-color-2);"></i> <span>0.50 сек</span></span>
                <span><i class="color-box" style="background: var(--history-color-3);"></i> <span>0.75 сек</span></span>
                <span><i class="color-box" style="background: var(--history-color-4);"></i> <span>1.00 сек</span></span>
            </div>
            <div class="history-zone-legend">
                <span><i class="color-box" style="background: var(--good-zone-color);"></i> <span>Хорошо (>0.8)</span></span>
                <span><i class="color-box" style="background: var(--warning-zone-color);"></i> <span>Удовлетворительно (0.5-0.8)</span></span>
                <span><i class="color-box" style="background: var(--bad-zone-color);"></i> <span>Тревожно (<0.5)</span></span>
            </div>
        </div>
    </div>

    <script>
        // Проверка поддержки Web Audio API
        if (!window.AudioContext && !window.webkitAudioContext) {
            document.getElementById('status').textContent = "Ваш браузер не поддерживает Web Audio API";
            document.getElementById('startBtn').disabled = true;
        }

        const DURATION = 15;
        const SAMPLE_RATE = 44100;
        const CHUNK_SIZE = 1024;
        const SIGNAL_AMPLIFICATION = 2.0;
        const MAX_HISTORY = 14; // Максимальное количество сохраняемых измерений

        const startBtn = document.getElementById('startBtn');
        const timerElement = document.getElementById('timer');
        const statusElement = document.getElementById('status');
        const graphTitle = document.getElementById('graph-title');
        const canvas = document.getElementById('graph');
        const ctx = canvas.getContext('2d');
        const resultsElement = document.getElementById('results');
        const startTimeResult = document.getElementById('start-time-result');
        const endTimeResult = document.getElementById('end-time-result');
        const intensityResult = document.getElementById('intensity-result');
        const languageButtons = document.querySelectorAll('.language-btn');
        const historySection = document.getElementById('history-section');
        const historyCanvas = document.getElementById('history-graph');
        const historyCtx = historyCanvas.getContext('2d');
        const historyLegend = document.querySelector('.history-legend');
        const deleteLastBtn = document.getElementById('deleteLastBtn');

        let audioContext;
        let analyser;
        let microphone;
        let recordingStartTime;
        let recordingInterval;
        let audioData = [];
        let backgroundNoise = [];
        let isRecording = false;
        let currentLanguage = 'ru';
        let measurementHistory = [];

        // Загрузка истории из localStorage
        function loadHistory() {
            try {
                const savedHistory = localStorage.getItem('measurementHistory');
                if (savedHistory) {
                    measurementHistory = JSON.parse(savedHistory);
                    // Ограничиваем историю последними 14 измерениями
                    if (measurementHistory.length > MAX_HISTORY) {
                        measurementHistory = measurementHistory.slice(-MAX_HISTORY);
                    }
                }
            } catch (e) {
                console.error('Ошибка загрузки истории:', e);
                measurementHistory = [];
            }
            updateDeleteButtonVisibility();
        }

        // Сохранение истории в localStorage
        function saveHistory() {
            try {
                localStorage.setItem('measurementHistory', JSON.stringify(measurementHistory));
            } catch (e) {
                console.error('Ошибка сохранения истории:', e);
            }
            updateDeleteButtonVisibility();
        }

        // Обновление видимости кнопки удаления
        function updateDeleteButtonVisibility() {
            if (measurementHistory.length > 0) {
                deleteLastBtn.style.display = 'block';
            } else {
                deleteLastBtn.style.display = 'none';
                historySection.style.display = 'none';
            }
        }

        // Удаление последней записи
        function deleteLastRecord() {
            if (measurementHistory.length > 0) {
                measurementHistory.pop();
                saveHistory();
                
                if (measurementHistory.length > 0) {
                    drawHistoryGraph();
                } else {
                    historySection.style.display = 'none';
                }
                
                // Показываем сообщение об успешном удалении
                const t = translations[currentLanguage];
                statusElement.textContent = t.lastRecordDeleted || "Последняя запись удалена";
                setTimeout(() => {
                    statusElement.textContent = t.readyStatus;
                }, 2000);
            }
        }

        // Добавление нового измерения в истории
        function addToHistory(startTime, endTime, cutoffIntensities) {
            const now = new Date();
            const measurement = {
                timestamp: now.toISOString(),
                date: now.toLocaleDateString(),
                time: now.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'}),
                startTime: startTime,
                endTime: endTime,
                cutoffIntensities: cutoffIntensities
            };
            
            measurementHistory.push(measurement);
            
            // Ограничиваем историю последними 14 измерениями
            if (measurementHistory.length > MAX_HISTORY) {
                measurementHistory = measurementHistory.slice(-MAX_HISTORY);
            }
            
            saveHistory();
        }

        // Тексты для перевода
        const translations = {
            ru: {
                title: "Анализ интенсивности звука с коррекцией фона",
                howToUse: "Как использовать:",
                usageDescription: "Нажмите кнопку \"Начать запись\", разрешите доступ к микрофону. После 15 секунд записи вы увидите график, где:",
                signalDesc: "Красная линия",
                signalText: "очищенный сигнал",
                backgroundDesc: "Зелёная линия",
                backgroundText: "фоновый шум",
                integralDesc: "Синяя линия",
                integralText: "интегральная кривая",
                startDesc: "Фиолетовая линия",
                startText: "момент старта сигнала",
                endDesc: "Розовая линия",
                endText: "момент окончания сигнала (99% интеграла)",
                cutoffDesc: "Оранжевая линия",
                cutoffText: "моменты отсечения (старт + 0.25, 0.50, 0.75, 1.00 сек)",
                startButton: "Начать запись (15 сек)",
                readyStatus: "Готов к записи",
                recordingStatus: "Идёт запись...",
                analyzingStatus: "Анализ данных...",
                completeStatus: "Анализ завершен",
                resultsTitle: "Результаты анализа:",
                startTimeResult: "Время старта:",
                endTimeResult: "Время финиша:",
                intensityResult: "Интенсивность в точке отсечения:",
                graphTitle: "График интенсивности звука",
                historyTitle: "История измерений (последние 14 сеансов)",
                legendSignal: "Сигнал",
                legendBackground: "Фон",
                legendIntegral: "Интеграл",
                legendStart: "Старт",
                legendEnd: "Финиш",
                legendCutoff: "Отсечение",
                timeLeft: "Осталось:",
                seconds: "сек",
                notDetected: "не обнаружено",
                notAvailable: "не доступно",
                startLabel: "Старт",
                finishLabel: "Финиш (99%)",
                cutoffLabel: "Отсечение",
                timeLabel: "Время (секунды)",
                intensityLabel: "Нормированная интенсивность",
                dateLabel: "Дата и время измерений",
                intensityHistoryLabel: "Интенсивность",
                deleteButton: "Удалить последнюю запись",
                lastRecordDeleted: "Последняя запись удалена",
                goodZoneLabel: "Хорошо (>0.8)",
                warningZoneLabel: "Удовлетворительно (0.5-0.8)",
                badZoneLabel: "Тревожно (<0.5)"
            },
            en: {
                title: "Sound Intensity Analysis with Background Correction",
                howToUse: "How to use:",
                usageDescription: "Click the \"Start Recording\" button, allow microphone access. After 15 seconds of recording, you will see a graph where:",
                signalDesc: "Red line",
                signalText: "cleaned signal",
                backgroundDesc: "Green line",
                backgroundText: "background noise",
                integralDesc: "Blue line",
                integralText: "integral curve",
                startDesc: "Purple line",
                startText: "signal start moment",
                endDesc: "Pink line",
                endText: "signal end moment (99% of integral)",
                cutoffDesc: "Orange line",
                cutoffText: "cutoff moments (start + 0.25, 0.50, 0.75, 1.00 sec)",
                startButton: "Start Recording (15 sec)",
                readyStatus: "Ready to record",
                recordingStatus: "Recording...",
                analyzingStatus: "Analyzing data...",
                completeStatus: "Analysis complete",
                resultsTitle: "Analysis Results:",
                startTimeResult: "Start time:",
                endTimeResult: "Finish time:",
                intensityResult: "Intensity at cutoff point:",
                graphTitle: "Sound Intensity Graph",
                historyTitle: "Measurement History (last 14 sessions)",
                legendSignal: "Signal",
                legendBackground: "Background",
                legendIntegral: "Integral",
                legendStart: "Start",
                legendEnd: "Finish",
                legendCutoff: "Cutoff",
                timeLeft: "Time left:",
                seconds: "sec",
                notDetected: "not detected",
                notAvailable: "not available",
                startLabel: "Start",
                finishLabel: "Finish (99%)",
                cutoffLabel: "Cutoff",
                timeLabel: "Time (seconds)",
                intensityLabel: "Normalized intensity",
                dateLabel: "Date and time of measurements",
                intensityHistoryLabel: "Intensity",
                deleteButton: "Delete last record",
                lastRecordDeleted: "Last record deleted",
                goodZoneLabel: "Good (>0.8)",
                warningZoneLabel: "Satisfactory (0.5-0.8)",
                badZoneLabel: "Alert (<0.5)"
            },
            he: {
                title: "ניתוח עוצמת קול עם תיקון רקע",
                howToUse: "כיצד להשתמש:",
                usageDescription: "לחץ על הכפתור \"התחל הקלטה\", אשר גישה למיקרופון. לאחר 15 שניות של הקלטה, תראה גרף שבו:",
                signalDesc: "קו אדום",
                signalText: "אות נקי",
                backgroundDesc: "קו ירוק",
                backgroundText: "רעש רקע",
                integralDesc: "קו כחול",
                integralText: "עקומה אינטגרלית",
                startDesc: "קו סגול",
                startText: "רגע תחילת האות",
                endDesc: "קו ורוד",
                endText: "רגע סיום האות (99% מהאינטגרל)",
                cutoffDesc: "קו כתום",
                cutoffText: "רגעי החיתוך (תחילה + 0.25, 0.50, 0.75, 1.00 שניות)",
                startButton: "התחל הקלטה (15 שניות)",
                readyStatus: "מוכן להקלטה",
                recordingStatus: "מקליט...",
                analyzingStatus: "מנתח נתונים...",
                completeStatus: "הניתוח הושלם",
                resultsTitle: "תוצאות ניתוח:",
                startTimeResult: "זמן התחלה:",
                endTimeResult: "זמן סיום:",
                intensityResult: "עוצמה בנקודת החיתוך:",
                graphTitle: "גרף עוצמת קול",
                historyTitle: "היסטוריית מדידות (14 המדידות האחרונות)",
                legendSignal: "אות",
                legendBackground: "רקע",
                legendIntegral: "אינטגרל",
                legendStart: "התחלה",
                legendEnd: "סיום",
                legendCutoff: "חיתוך",
                timeLeft: "נשארו:",
                seconds: "שניות",
                notDetected: "לא אותר",
                notAvailable: "לא זמין",
                startLabel: "התחלה",
                finishLabel: "סיום (99%)",
                cutoffLabel: "חיתוך",
                timeLabel: "זמן (שניות)",
                intensityLabel: "עוצמה מנורמלת",
                dateLabel: "תאריך ושעה של המדידות",
                intensityHistoryLabel: "עוצמה",
                deleteButton: "מחק רשומה אחרונה",
                lastRecordDeleted: "הרשומה האחרונה נמחקה",
                goodZoneLabel: "טוב (>0.8)",
                warningZoneLabel: "משביע רצון (0.5-0.8)",
                badZoneLabel: "מדאיג (<0.5)"
            }
        };

        // Функция смены языка
        function changeLanguage(lang) {
            currentLanguage = lang;
            const t = translations[lang];
            
            // Обновляем тексты интерфейса
            document.getElementById('main-title').textContent = t.title;
            document.getElementById('how-to-use').textContent = t.howToUse;
            document.getElementById('usage-description').textContent = t.usageDescription;
            document.getElementById('signal-desc').textContent = t.signalDesc;
            document.getElementById('signal-text').textContent = t.signalText;
            document.getElementById('background-desc').textContent = t.backgroundDesc;
            document.getElementById('background-text').textContent = t.backgroundText;
            document.getElementById('integral-desc').textContent = t.integralDesc;
            document.getElementById('integral-text').textContent = t.integralText;
            document.getElementById('start-desc').textContent = t.startDesc;
            document.getElementById('start-text').textContent = t.startText;
            document.getElementById('end-desc').textContent = t.endDesc;
            document.getElementById('end-text').textContent = t.endText;
            document.getElementById('cutoff-desc').textContent = t.cutoffDesc;
            document.getElementById('cutoff-text').textContent = t.cutoffText;
            startBtn.textContent = t.startButton;
            document.getElementById('results-title').textContent = t.resultsTitle;
            document.getElementById('graph-title').textContent = t.graphTitle;
            document.getElementById('history-title').textContent = t.historyTitle;
            document.getElementById('legend-signal').textContent = t.legendSignal;
            document.getElementById('legend-background').textContent = t.legendBackground;
            document.getElementById('legend-integral').textContent = t.legendIntegral;
            document.getElementById('legend-start').textContent = t.legendStart;
            document.getElementById('legend-end').textContent = t.legendEnd;
            document.getElementById('legend-cutoff').textContent = t.legendCutoff;
            deleteLastBtn.textContent = t.deleteButton;
            
            // Обновляем легенду зон
            const zoneLegendItems = document.querySelectorAll('.history-zone-legend > span');
            if (zoneLegendItems.length >= 3) {
                zoneLegendItems[0].querySelector('span').textContent = t.goodZoneLabel;
                zoneLegendItems[1].querySelector('span').textContent = t.warningZoneLabel;
                zoneLegendItems[2].querySelector('span').textContent = t.badZoneLabel;
            }
            
            // Обновляем статус, если не идет запись
            if (!isRecording) {
                statusElement.textContent = t.readyStatus;
            }
            
            // Обновляем направление текста для иврита
            if (lang === 'he') {
                document.body.classList.add('rtl');
                document.querySelector('.container').style.direction = 'rtl';
                document.querySelector('.info-box').style.textAlign = 'right';
            } else {
                document.body.classList.remove('rtl');
                document.querySelector('.container').style.direction = 'ltr';
                document.querySelector('.info-box').style.textAlign = 'left';
            }
            
            // Обновляем активную кнопку языка
            languageButtons.forEach(btn => {
                if (btn.dataset.lang === lang) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Перерисовываем график, если данные уже есть
            if (audioData.length > 0) {
                processAndDrawData();
            }
            
            // Перерисовываем график истории
            if (measurementHistory.length > 0) {
                drawHistoryGraph();
            }
        }

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: SAMPLE_RATE
                });
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                return true;
            } catch (e) {
                console.error("Ошибка инициализации аудио:", e);
                statusElement.textContent = translations[currentLanguage].errorAudioInit || "Ошибка инициализации аудио";
                return false;
            }
        }

        async function startRecording() {
            try {
                if (!audioContext && !initAudio()) {
                    return;
                }
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                recordingStartTime = audioContext.currentTime;
                isRecording = true;
                audioData = [];
                backgroundNoise = [];
                
                startBtn.disabled = true;
                statusElement.textContent = translations[currentLanguage].recordingStatus;
                statusElement.classList.add('recording');
                graphTitle.style.display = 'none';
                resultsElement.style.display = 'none';
                historySection.style.display = 'none';
                
                processAudio();
                
                let secondsLeft = DURATION;
                updateTimer(secondsLeft);
                
                recordingInterval = setInterval(() => {
                    secondsLeft--;
                    updateTimer(secondsLeft);
                    
                    if (secondsLeft <= 0) {
                        stopRecording();
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Ошибка при записи:', error);
                statusElement.textContent = translations[currentLanguage].errorRecording || "Ошибка записи: " + error.message;
                resetRecordingState();
            }
        }

        function processAudio() {
            if (!isRecording) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            const timestamp = audioContext.currentTime - recordingStartTime;
            
            // Усиление сигнала вдвое
            const normalizedData = Array.from(dataArray).map(x => (x - 128) / 128 * SIGNAL_AMPLIFICATION);
            
            audioData.push({
                time: timestamp,
                data: normalizedData
            });
            
            if (timestamp < 2) {
                backgroundNoise.push({
                    x: timestamp / DURATION,
                    y: calculateRMS(normalizedData)
                });
            }
            
            requestAnimationFrame(processAudio);
        }

        function calculateRMS(data) {
            let sum = 0;
            for (let i = 0; i < data.length; i++) {
                sum += data[i] * data[i];
            }
            return Math.sqrt(sum / data.length);
        }

        function stopRecording() {
            clearInterval(recordingInterval);
            isRecording = false;
            
            if (microphone) {
                microphone.disconnect();
            }
            
            statusElement.textContent = translations[currentLanguage].analyzingStatus;
            statusElement.classList.remove('recording');
            
            setTimeout(() => {
                processAndDrawData();
                resetRecordingState();
            }, 500);
        }

        function findSignalStart(integralData, sampleRate) {
            const SMOOTHING_WINDOW = 0.5;
            const THRESHOLD_FACTOR = 5;
            const MIN_DURATION = 0.3;
            const START_IGNORE_TIME = 0.5;

            const windowSize = Math.floor(SMOOTHING_WINDOW * sampleRate);
            let startIndex = -1;

            let means = [], stdDevs = [];
            for (let i = 0; i < integralData.length; i++) {
                const start = Math.max(0, i - windowSize);
                const window = integralData.slice(start, i).map(p => p.y);
                const mean = window.reduce((a, b) => a + b, 0) / window.length;
                const stdDev = window.length > 1 ? 
                    Math.sqrt(window.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (window.length - 1)) : 0;
                
                means.push(mean);
                stdDevs.push(stdDev);
            }

            const ignoreIndex = Math.floor(START_IGNORE_TIME * sampleRate);
            for (let i = ignoreIndex; i < integralData.length; i++) {
                const threshold = means[i] + THRESHOLD_FACTOR * stdDevs[i];
                
                if (integralData[i].y > threshold) {
                    let isSignal = true;
                    for (let j = i; j < Math.min(i + MIN_DURATION * sampleRate, integralData.length); j++) {
                        if (integralData[j].y <= threshold) {
                            isSignal = false;
                            break;
                        }
                    }
                    if (isSignal) {
                        startIndex = i;
                        break;
                    }
                }
            }

            return startIndex >= 0 ? integralData[startIndex].x * DURATION : -1;
        }

        function findSignalEnd(integralData, sampleRate, startTime) {
            if (startTime < 0) return -1;

            const maxIntegralValue = Math.max(...integralData.map(p => p.y));
            if (maxIntegralValue <= 0) return -1;

            const targetValue = 0.99 * maxIntegralValue;
            let endIndex = -1;

            for (let i = 0; i < integralData.length; i++) {
                if (integralData[i].x * DURATION >= startTime && integralData[i].y >= targetValue) {
                    endIndex = i;
                    break;
                }
            }

            return endIndex >= 0 ? integralData[endIndex].x * DURATION : -1;
        }

        function processAndDrawData() {
            if (audioData.length === 0) {
                statusElement.textContent = translations[currentLanguage].noData || "Нет данных для анализа";
                return;
            }
            
            try {
                const avgBackgroundNoise = backgroundNoise.reduce((sum, point) => sum + point.y, 0) / backgroundNoise.length;
                
                const originalSignal = [];
                const backgroundSignal = [];
                const timeStep = DURATION / audioData.length;
                
                for (let i = 0; i < audioData.length; i++) {
                    const point = audioData[i];
                    const intensity = calculateRMS(point.data);
                    
                    originalSignal.push(intensity);
                    backgroundSignal.push({
                        x: point.time / DURATION,
                        y: avgBackgroundNoise
                    });
                }
                
                const integralSignal = calculateIntegralCurve(originalSignal, avgBackgroundNoise);
                
                const sampleRate = audioData.length / DURATION;
                const startTime = findSignalStart(integralSignal, sampleRate);
                const endTime = findSignalEnd(integralSignal, sampleRate, startTime);
                
                // Вычисляем моменты отсечения
                const cutoffTimes = [];
                if (startTime > 0) {
                    cutoffTimes.push(startTime + 0.25);
                    cutoffTimes.push(startTime + 0.50);
                    cutoffTimes.push(startTime + 0.75);
                    cutoffTimes.push(startTime + 1.00);
                }
                
                console.log("Start time:", startTime, "End time:", endTime, "Cutoff times:", cutoffTimes);
                
                const maxIntegralValue = Math.max(...integralSignal.map(p => p.y));
                const normalizedIntegral = integralSignal.map(p => ({
                    x: p.x,
                    y: maxIntegralValue > 0 ? p.y / maxIntegralValue : 0
                }));
                
                // Вычисляем интенсивность в точках отсечения
                const cutoffIntensities = [];
                if (startTime > 0) {
                    for (const cutoffTime of cutoffTimes) {
                        if (cutoffTime > 0 && cutoffTime < DURATION) {
                            const cutoffIndex = Math.floor(cutoffTime / timeStep);
                            if (cutoffIndex >= 0 && cutoffIndex < normalizedIntegral.length) {
                                cutoffIntensities.push(normalizedIntegral[cutoffIndex].y);
                            } else {
                                cutoffIntensities.push(-1);
                            }
                        } else {
                            cutoffIntensities.push(-1);
                        }
                    }
                }
                
                // Добавляем в истории
                if (startTime > 0 && cutoffIntensities.length > 0) {
                    addToHistory(startTime, endTime, cutoffIntensities);
                    drawHistoryGraph();
                }
                
                drawGraph(originalSignal, backgroundSignal, normalizedIntegral, startTime, endTime, cutoffTimes);
                
                // Обновляем результаты
                const t = translations[currentLanguage];
                startTimeResult.textContent = `${t.startTimeResult} ${startTime > 0 ? startTime.toFixed(3) + " " + t.seconds : t.notDetected}`;
                endTimeResult.textContent = `${t.endTimeResult} ${endTime > 0 ? endTime.toFixed(3) + " " + t.seconds : t.notDetected}`;
                
                let intensityText = `${t.intensityResult} `;
                if (cutoffIntensities.length > 0) {
                    intensityText += cutoffIntensities.map((intensity, index) => 
                        `${(startTime + (index + 1) * 0.25).toFixed(2)}s: ${intensity >= 0 ? (intensity * 100).toFixed(1) + "%" : t.notAvailable}`
                    ).join(", ");
                } else {
                    intensityText += t.notAvailable;
                }
                intensityResult.textContent = intensityText;
                
                resultsElement.style.display = 'block';
                graphTitle.style.display = 'block';
                statusElement.textContent = t.completeStatus;
                
            } catch (error) {
                console.error('Ошибка при обработке данных:', error);
                statusElement.textContent = translations[currentLanguage].errorProcessing || "Ошибка обработки данных: " + error.message;
            }
        }

        function calculateIntegralCurve(signal, background) {
            const integral = [];
            let sum = 0;
            
            for (let i = 0; i < signal.length; i++) {
                const correctedValue = Math.max(0, signal[i] - background);
                sum += correctedValue;
                integral.push({
                    x: i / signal.length,
                    y: sum
                });
            }
            
            return integral;
        }

        function drawGraph(signal, background, integral, startTime, endTime, cutoffTimes) {
            // Resolve CSS custom properties to concrete colors for Canvas
            const styles = getComputedStyle(document.documentElement);
            const signalColor = styles.getPropertyValue('--signal-color').trim();
            const backgroundColor = styles.getPropertyValue('--background-color').trim();
            const integralColor = styles.getPropertyValue('--integral-color').trim();
            const startColor = styles.getPropertyValue('--start-color').trim();
            const endColor = styles.getPropertyValue('--end-color').trim();
            const cutoffColor = styles.getPropertyValue('--cutoff-color').trim();

            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            
            ctx.clearRect(0, 0, width, height);
            
            // Рисуем сетку
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 1;
            
            // Вертикальные линии
            for (let i = 0; i <= 10; i++) {
                const x = padding + i * (width - 2 * padding) / 10;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }
            
            // Горизонтальные линии
            for (let i = 0; i <= 5; i++) {
                const y = padding + i * (height - 2 * padding) / 5;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Оси
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            
            // Ось X
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Ось Y
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            // Подписи осей
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            
            // Подписи оси X
            for (let i = 0; i <= 10; i++) {
                const x = padding + i * (width - 2 * padding) / 10;
                const time = (i * DURATION / 10).toFixed(1);
                ctx.fillText(time, x, height - padding + 20);
            }
            
            // Подпись оси X
            const t = translations[currentLanguage];
            ctx.fillText(t.timeLabel, width / 2, height - 5);
            
            // Подписи оси Y
            ctx.save();
            ctx.translate(10, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(t.intensityLabel, 0, 0);
            ctx.restore();
            
            // Функция для преобразования координат
            const scaleX = (x) => padding + x * (width - 2 * padding);
            const scaleY = (y) => height - padding - y * (height - 2 * padding);
            
            // Рисуем фоновый шум
            ctx.beginPath();
            ctx.strokeStyle = backgroundColor;
            ctx.lineWidth = 2;
            
            for (let i = 0; i < background.length; i++) {
                const point = background[i];
                const x = scaleX(point.x);
                const y = scaleY(point.y);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Нормализуем сигнал для отображения
            const maxSignal = Math.max(...signal);
            const normalizedSignal = signal.map(value => value / maxSignal);
            
            // Рисуем сигнал
            ctx.beginPath();
            ctx.strokeStyle = signalColor;
            ctx.lineWidth = 2;
            
            for (let i = 0; i < normalizedSignal.length; i++) {
                const x = scaleX(i / normalizedSignal.length);
                const y = scaleY(normalizedSignal[i]);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Рисуем интегральную кривую
            ctx.beginPath();
            ctx.strokeStyle = integralColor;
            ctx.lineWidth = 2;
            
            for (let i = 0; i < integral.length; i++) {
                const point = integral[i];
                const x = scaleX(point.x);
                const y = scaleY(point.y);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Рисуем вертикальные линии для старта, финиша и отсечения
            if (startTime > 0) {
                const startX = scaleX(startTime / DURATION);
                
                // Линия старта
                ctx.beginPath();
                ctx.strokeStyle = startColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.moveTo(startX, padding);
                ctx.lineTo(startX, height - padding);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Подпись старта
                ctx.fillStyle = startColor;
                ctx.fillText(t.startLabel, startX, padding - 10);
            }
            
            if (endTime > 0) {
                const endX = scaleX(endTime / DURATION);
                
                // Линия финиша
                ctx.beginPath();
                ctx.strokeStyle = endColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.moveTo(endX, padding);
                ctx.lineTo(endX, height - padding);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Подпись финиша
                ctx.fillStyle = endColor;
                ctx.fillText(t.finishLabel, endX, padding - 10);
            }
            
            // Линии отсечения
            for (let i = 0; i < cutoffTimes.length; i++) {
                const cutoffTime = cutoffTimes[i];
                if (cutoffTime > 0 && cutoffTime < DURATION) {
                    const cutoffX = scaleX(cutoffTime / DURATION);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = cutoffColor;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.moveTo(cutoffX, padding);
                    ctx.lineTo(cutoffX, height - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Подпись отсечения
                    ctx.fillStyle = cutoffColor;
                    ctx.fillText(`${t.cutoffLabel} ${i + 1}`, cutoffX, padding - 25);
                }
            }
        }

        function drawHistoryGraph() {
            // Get computed CSS variables for history colors
            const styles = getComputedStyle(document.documentElement);
            const historyColor1 = styles.getPropertyValue('--history-color-1').trim();
            const historyColor2 = styles.getPropertyValue('--history-color-2').trim();
            const historyColor3 = styles.getPropertyValue('--history-color-3').trim();
            const historyColor4 = styles.getPropertyValue('--history-color-4').trim();
            const goodZoneColor = styles.getPropertyValue('--good-zone-color').trim();
            const warningZoneColor = styles.getPropertyValue('--warning-zone-color').trim();
            const badZoneColor = styles.getPropertyValue('--bad-zone-color').trim();

            if (measurementHistory.length === 0) {
                historySection.style.display = 'none';
                return;
            }
            
            historySection.style.display = 'block';
            const width = historyCanvas.width;
            const height = historyCanvas.height;
            const padding = { top: 40, right: 60, bottom: 80, left: 80 };
            
            historyCtx.clearRect(0, 0, width, height);
            
            // Рисуем цветные зоны фона
            drawBackgroundZones(historyCtx, padding, width, height, goodZoneColor, warningZoneColor, badZoneColor);
            
            // Рисуем сетку
            historyCtx.strokeStyle = '#E0E0E0';
            historyCtx.lineWidth = 1;
            
            // Вертикальные линии
            for (let i = 0; i <= 10; i++) {
                const x = padding.left + i * (width - padding.left - padding.right) / 10;
                historyCtx.beginPath();
                historyCtx.moveTo(x, padding.top);
                historyCtx.lineTo(x, height - padding.bottom);
                historyCtx.stroke();
            }
            
            // Горизонтальные линии
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + i * (height - padding.top - padding.bottom) / 5;
                historyCtx.beginPath();
                historyCtx.moveTo(padding.left, y);
                historyCtx.lineTo(width - padding.right, y);
                historyCtx.stroke();
            }
            
            // Оси
            historyCtx.strokeStyle = '#888';
            historyCtx.lineWidth = 2;
            
            // Ось X
            historyCtx.beginPath();
            historyCtx.moveTo(padding.left, height - padding.bottom);
            historyCtx.lineTo(width - padding.right, height - padding.bottom);
            historyCtx.stroke();
            
            // Ось Y
            historyCtx.beginPath();
            historyCtx.moveTo(padding.left, padding.top);
            historyCtx.lineTo(padding.left, height - padding.bottom);
            historyCtx.stroke();
            
            // Подписи осей
            historyCtx.fillStyle = '#333';
            historyCtx.font = '14px Arial';
            
            // Подпись оси X
            historyCtx.textAlign = 'center';
            const t = translations[currentLanguage];
            historyCtx.fillText(t.dateLabel, width / 2, height - 15);
            
            // Подпись оси Y
            historyCtx.save();
            historyCtx.translate(20, height / 2);
            historyCtx.rotate(-Math.PI / 2);
            historyCtx.fillText(t.intensityHistoryLabel, 0, 0);
            historyCtx.restore();
            
            // Подписи значений оси Y
            historyCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = i * 0.2;
                const y = padding.top + (5 - i) * (height - padding.top - padding.bottom) / 5;
                historyCtx.fillText(value.toFixed(1), padding.left - 10, y + 5);
            }
            
            // Подписи дат на оси X
            const barWidth = (width - padding.left - padding.right) / measurementHistory.length;
            historyCtx.textAlign = 'center';
            historyCtx.save();
            historyCtx.translate(0, 0);
            
            measurementHistory.forEach((measurement, index) => {
                const x = padding.left + (index + 0.5) * barWidth;
                historyCtx.fillText(measurement.date, x, height - padding.bottom + 20);
                historyCtx.fillText(measurement.time, x, height - padding.bottom + 40);
            });
            
            historyCtx.restore();
            
            // Цвета для точек отсечения
            const cutoffColors = [
                historyColor1, // 0.25s
                historyColor2, // 0.50s
                historyColor3, // 0.75s
                historyColor4  // 1.00s
            ];
            
            // Рисуем точки для каждого измерения
            measurementHistory.forEach((measurement, index) => {
                const x = padding.left + (index + 0.5) * barWidth;
                
                // Рисуем точки для каждой временной точки отсечения
                measurement.cutoffIntensities.forEach((intensity, cutoffIndex) => {
                    if (intensity >= 0) {
                        const y = padding.top + (1 - intensity) * (height - padding.top - padding.bottom);
                        
                        historyCtx.beginPath();
                        historyCtx.fillStyle = cutoffColors[cutoffIndex];
                        historyCtx.arc(x, y, 5, 0, 2 * Math.PI);
                        historyCtx.fill();
                    }
                });
            });
            
            // Рисуем соединительные линии для каждой временной точки
            cutoffColors.forEach((color, cutoffIndex) => {
                historyCtx.beginPath();
                historyCtx.strokeStyle = color;
                historyCtx.lineWidth = 2;
                
                let firstPoint = true;
                
                measurementHistory.forEach((measurement, index) => {
                    const intensity = measurement.cutoffIntensities[cutoffIndex];
                    if (intensity >= 0) {
                        const x = padding.left + (index + 0.5) * barWidth;
                        const y = padding.top + (1 - intensity) * (height - padding.top - padding.bottom);
                        
                        if (firstPoint) {
                            historyCtx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            historyCtx.lineTo(x, y);
                        }
                    }
                });
                
                historyCtx.stroke();
            });
        }

        // Функция для рисования цветных зон фона
        function drawBackgroundZones(ctx, padding, width, height, goodColor, warningColor, badColor) {
            const graphHeight = height - padding.top - padding.bottom;
            
            // Красная зона (< 0.5)
            ctx.fillStyle = badColor;
            ctx.fillRect(
                padding.left, 
                padding.top + graphHeight * 0.5, 
                width - padding.left - padding.right, 
                graphHeight * 0.5
            );
            
            // Желтая зона (0.5-0.8)
            ctx.fillStyle = warningColor;
            ctx.fillRect(
                padding.left, 
                padding.top + graphHeight * 0.2, 
                width - padding.left - padding.right, 
                graphHeight * 0.3
            );
            
            // Зеленая зона (≥ 0.8)
            ctx.fillStyle = goodColor;
            ctx.fillRect(
                padding.left, 
                padding.top, 
                width - padding.left - padding.right, 
                graphHeight * 0.2
            );
        }

        function updateTimer(seconds) {
            const t = translations[currentLanguage];
            timerElement.textContent = `${t.timeLeft} ${seconds} ${t.seconds}`;
        }

        function resetRecordingState() {
            startBtn.disabled = false;
            timerElement.textContent = '';
        }

        // Инициализация
        startBtn.addEventListener('click', startRecording);
        
        languageButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                changeLanguage(btn.dataset.lang);
            });
        });
        
        // Обработчик для кнопки удаления последней записи
        deleteLastBtn.addEventListener('click', deleteLastRecord);
        
        // Загружаем историю при запуске
        loadHistory();
        
        // Инициализируем язык по умолчанию
        changeLanguage('ru');
    </script>
</body>
</html>